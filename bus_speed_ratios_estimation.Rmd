---
title: "Bus Speed Ratios Estimation"
author: "Chris Day"
date: "2022-10-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# {.tabset}

```{r libraries, warning=FALSE, message=FALSE, include=FALSE}
library(tidyverse)
library(sf)
library(gtfstools)
library(gtfs2gps)
library(leaflet)
library(hms)
library(geotidy)
library(sfheaders)
library(targets)
library(rmarkdown)
library(lwgeom)
library(nngeo)
library(foreign)
library(kableExtra)
library(zoo)
library(data.table)
library(animation)
source("R/bus_speeds_visuals.R")
source("R/bus_speeds.R")
source("R/gtfs_functions.R")
source("R/estimation_functions.R")
```

## Introduction 
### Purpose
This Rmarkdown is for estimating new traffic to bus speed ratios using traffic speeds from an output congested TDM network and GTFS bus schedule data. The traffic to bus speed ratios represent the speed ratio for which buses travel in the TDM network. In other words, compared to how fast traffic moves in the TDM, what ratio of that speed will buses travel?

### Current Ratios

The current ratios being used to determining TDM bus travel speeds are as follows:

```{r currentratios, echo=FALSE}
df <- data.frame (FTGCLASS  = c("FT-Freeways", "FT-Ramps", "FT-Principal Arterials & Expressways", "FT-Minor Arterials (Urban)", "FT-Minor Arterials (Suburban)", "FT-Collectors & Locals"),
                  AutoSpeedRatio = c(.95, 0.75, 0.60, 0.55, 0.65, 0.60))
kbl(df) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

*minimum bus speed = 10mph

As seen in the table, ratios are constant for all buses of the same functional class (except for minor arterials where it varies by area type as well). Similarly, part of our process will be to analyze how different functional classes and area types affect the speed ratios. 

For more information on the GTFS data, or other data that could have been used in this estimation, please refer to the bus_speeds.R and gtfs_bus_speeds.rmd files within the project directory. Within those validation scripts, we determined that GTFS data was a more stable dataset for estimation purposes.

### Process for Estimation
The data munging required for estimation is slightly complicated, and so the outlined process is explained in the following steps.

  - *STEP 1*: Match the congested traffic speed, functional class, and area type of the nearest TDM link to each GTFS link. 
  
      a. Determine period (peak/off-peak) and compass direction (NB,SB,EB,WB) for all TDM links and GTFS links
      
      b. Join TDM speed attributes to GTFS links by period and compass direction
      
      c. Delete all GTFS links that were unable to match with a TDM link or matched with a link way too far away.
      
  - *STEP 2*: Using the GTFS link distance and the TDM speed, calculate the modeled link travel traverse time. Also calculate the GTFS observed link travel traverse time.
  
  - *STEP 3*: Calculate the cumulative link travel traverse time for both observed and modeled data by summing together travel times by period and functional classification and area type.
  
  - *STEP 4*: Calculate the congested speed to bus speed ratio by dividing the cumulative travel traverse times. Do this by period and functional classification and area type. 
  
      a. Also do this where area type is not accounted for.
    
      b. Also do this where period is not acounted for.

## Step 1
### Prepare TDM Data
Before matching TDM attributes to the GTFS link, we need to prepare the TDM data. First, we read in the Distribution Network Link SHP with the needed attributes. 
  
```{r tdmprep, warning=FALSE, message=FALSE}
tdmshpfile <- "data/TDM/Distrib_Network/Distrib_Network__Summary.shp"

tdmlinkshp <- st_read(tdmshpfile, quiet = TRUE) %>%
  select(LINKID, FT, FTCLASS, AREATYPE, DIRECTION, AM_SPD, MD_SPD, geometry, ATYPENAME, ATYPEGRP, PM_SPD, EV_SPD, EV_SPD, DY_SPD)
paged_table(tdmlinkshp)
```

After reading in the SHP data, we need to filter the link dataset to only include those links that correspond to bus routes. We also need to attach the route id to each link. We do this below.

```{r tdmroutes, warning=FALSE,message=FALSE}
tdm_link_shp_attributes <- tdmlinkshp  %>% as_tibble()
tdm_uta_conversion <- tar_read(tdm_uta_conversion)

transit_line_file <- "data/TDM/Distrib_Network/_v832_SE19_Net19_2_OD_Station_Detail.dbf"
tdm_summary_all <- read.dbf(transit_line_file) %>%
  group_by(MODE,NAME,NAMEID) %>%
  mutate(B = lead(A)) %>%
  select(MODE,NAMEID,NAME,ONEWAY,LINKSEQ1,LINKSEQ2,A,B,STOPS,DIST) %>%
  mutate(LINKID = paste0(A,"_",B)) %>%
  left_join(tdm_link_shp_attributes) %>%
  filter(!is.na(FT)) %>%
  left_join(tdm_uta_conversion, by = c("NAME"="TDMRoute")) %>%
  select(-UTARoute,-Notes,-GTFSRoute) %>%
  mutate(compass = DIRECTION) %>%
  st_as_sf(crs = 26912) %>%
  st_transform(4326)
```

### Prepare GTFS Data
The input TDM link shapefile already has link id, functional class, areatype, compass direction, and peak and off-peak speeds so no more manipulation is needed to prepare that input. Now, we read in the GTFS data of corresponding attributes. In the gtfs_bus_speeds.Rmd and gtfs_functions.R, a lot of data munging has already been completed, so we read in the partially manipulated GTFS data.

```{r gtfsprep}
gtfs_summary_data <- tar_read(speed_sums)
```

This gtfs summary data is composed of polylines, instead of individual line segments. For this analysis however, we want to keep it as polylines. The summary data still needs some munging though. We still need to add compass direction, convert to the correct units, and add common route labeling. We do this below.

```{r gtfsmung}
gtfs_summary_compass <- gtfs_summary_data %>% 
  mutate(startpoint = st_startpoint(geometry),
         endpoint = st_endpoint(geometry)) %>%
  mutate(azimuth = st_azimuth(startpoint,endpoint)) %>%
  mutate(compass = ifelse(azimuth > 315 | azimuth <= 45, "NB",
                   ifelse(azimuth > 45 & azimuth <= 135, "EB",
                   ifelse(azimuth > 135 & azimuth <= 225, "SB",
                   ifelse(azimuth > 225 & azimuth <= 315, "WB", NA))))
         ) %>%
  mutate(aveSpeed = as.numeric(aveSpeed) * 0.621371,
         aveDistance = as.numeric(aveDistance)* 0.000621371) %>%
  as_tibble() %>%
  left_join(tdm_uta_conversion, by = c("route_short_name" = "GTFSRoute")) %>%
  select(-Notes,-UTARoute,-TDMRoute) %>%
  st_as_sf()

gtfs_summary_all <- gtfs_summary_compass %>%
  select(-startpoint,-endpoint) %>%
  group_by(route_short_name,PkOk,direction_id) %>%
  mutate(rownum = row_number()) %>%
  mutate(uniquerow = paste0(route_short_name,PkOk,direction_id,rownum))
```

To double check that the compass direction look good lets take a look at route 11. 

```{r filterroutes, message=FALSE, warning=FALSE, include=FALSE}
route <- "11"
period <- "pk"
gtfs_summary_all_filtered <- gtfs_summary_all %>%
  filter(route_short_name == route,
         PkOk == period) 
uta_gps_points_filtered <- tar_read(stop_locations) %>%
  filter(route_short_name == route,
         PkOk == period) 
```

```{r route11map, echo = FALSE}
leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolylines(
    data = gtfs_summary_all_filtered$geometry,
    popup = paste("DIR:", gtfs_summary_all_filtered$compass, "<br>",
                  "Angle", gtfs_summary_all_filtered$azimuth, "<br>",
                  "Ave Speed", gtfs_summary_all_filtered$aveSpeed, "<br>",
                  "Dist", gtfs_summary_all_filtered$aveDistance,"<br>",
                  "stop_seq", gtfs_summary_all_filtered$stop_sequence)
  ) %>%
  addCircleMarkers(lng = uta_gps_points_filtered$long, 
      lat = uta_gps_points_filtered$lat,
      popup = paste("stop_seq", uta_gps_points_filtered$stop_sequence),
      color = "red")
  #addCircleMarkers(lng = gtfs_cf$long, lat = gtfs_cf$lat,
  #                 color = "Blue")
```

### Combine TDM and GTFS Data
Now that both TDM and GTFS spatial objects contain the correct information, we are almost ready to merge the TDM speed data to the GTFS links. First, we create a centroid object for all the GTFS polylines. These centroids will be used to find the closest TDM link to that GTFS polyline. 

```{r gtfscentroids, warning=FALSE, message=FALSE}
gtfs_summary_centroids <- gtfs_summary_all %>% make_centerpoint() %>%
  st_as_sf(crs = 26912) %>%
  st_transform(4326)

gtfs_cf <- gtfs_summary_centroids %>%
  mutate(long = unlist(map(gtfs_summary_centroids$midlinep,1)),
           lat = unlist(map(gtfs_summary_centroids$midlinep,2))) %>%
  filter(route_short_name == route,
         PkOk == period) 
```

Now that we have a centroid object, we can match the closest TDM link to each GTFS centroid. That centroid object will then take on all the TDM attributes. We then merge those attribute back onto the GTFS link object! 

```{r gtfstdmjoin}
gtfs_with_tdm <- join_to_gtfs(tdm_summary_all,gtfs_summary_centroids) %>%
  select(-Label.1, -LabelNum.1, -compass.1)

gtfs_with_tdm_short <- gtfs_with_tdm %>%
  select(LINKID, centroid_id,FT,FTCLASS,AREATYPE,AM_SPD,MD_SPD,dist, uniquerow) %>%
  as_tibble() %>% select(-midlinep)

gtfs_with_tdm_lines <- gtfs_summary_all %>%
  left_join(gtfs_with_tdm_short, by = c("uniquerow")) 
```

Now that we have GTFS links with TDM attributes, lets make a map to verify that our process worked correctly. Below is a map of the GTFS centroids and GTFS links (red) alongside the TDM links (blue). 

```{r joinmaptest, include = FALSE}
labelnum <- 45
period <- "pk"

tdm_test <- tdm_summary_all %>%
  filter(LabelNum == 45) %>%
  st_as_sf()
gtfsp_test <- gtfs_with_tdm %>%
    ungroup()%>%
  mutate(long = unlist(map(gtfs_with_tdm$midlinep,1)),
           lat = unlist(map(gtfs_with_tdm$midlinep,2))) %>%
  filter(LabelNum == 45,
         PkOk == period)
gtfsl_test <- gtfs_with_tdm_lines %>%
  filter(LabelNum == 45,
         PkOk == period) %>%
  st_as_sf()
```

```{r jointmaptest, echo = FALSE}
leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolylines(
    data = tdm_test$geometry,
    popup = paste("DIR: ", tdm_test$compass, "<br>",
                  "AM Speed: ", tdm_test$AM_SPD, "<br>",
                  "LINKID: ", tdm_test$LINKID, "<br>",
                  "LINKSEQ1: ", tdm_test$LINKSEQ1)
  ) %>%
  addCircleMarkers(lng = gtfsp_test$long, 
      lat = gtfsp_test$lat,
      popup = paste("DIR: ", gtfsp_test$compass, "<br>",
                    "AM Speed: ", gtfsp_test$AM_SPD, "<br>",
                    "LINKID: ", gtfsp_test$LINKID, "<br>",
                    "LINKSEQ1: ", gtfsp_test$LINKSEQ1),
      color = "red"
  ) %>%
  addPolylines(
    data = gtfsl_test$geometry,
    popup = paste("DIR: ", gtfsl_test$compass, "<br>",
                  "AM Speed: ", gtfsl_test$AM_SPD, "<br>",
                  "LINKSEQ1: ", gtfsl_test$LINKID, "<br>"),
    color = "red"
  )
```



### Delete Unreasonable or Mismatched Data
In some cases, when doing the matching process some GTFS links were not matched with a TDM link. Therefore, there are some GTFS links with empty values. We must filter those out before calculating the ratios. There are also GTFS links that did get TDM attributes, but the distance at which they received data is unreasonably far. Therefore, we must also filter out any link that received TDM data from too far away. Lastly, some of the GTFS speed calculations were not perfect. So in addition, we filter out any speed calculation that doesn't make sense (i.e. a bus speed traveling 50mph faster or slower than actual road speeds). The distance and speed filter is based on arbitrary numbers, and can be changed later on if these ones don't make sense.

```{r}
gtfs_with_tdm_clean <- clean_gtfs_joint_data(gtfs_with_tdm_lines, 30, 2500)
```


## Step 2-4
### Link Travel Traverse Time
Now that we have a dataset of all the GTFS links with TDM speed data, we need to calculate the modeled link traverse time using the GTFS distance. The GTFS link traverse time has already been calculated. This step is completed below.

```{r traversetime}
traversetime <- gtfs_with_tdm_clean %>%
  mutate(ModeledTime = aveDistance / Modeled * 3600, 
         ObservedTime = aveDistance / Observed * 3600)
```

### Cumulative Link Travel Traverse Time
Now that we have link traverse time for modeled and observed, we can calculate the summed traverse time by period and functional classificiation and area type. Before doing this however, we need to create the option to group the functional types together by the existing groupings. This is done below.

```{r ftg}
traversetime_ftg <- traversetime %>%
  as_tibble() %>% select(-geometry) %>%
  mutate(
      FTG = case_when(
        FT %in% c(20:26,30:40) ~ 30,
        FT %in% c(28:29,41:42) ~ 40,
        FT == 3 & AREATYPE %in% c(4,5) ~ 3,
        FT == 3  & AREATYPE %in% c(1,2,3) ~ 4,
        FT %in% c(1,4:8) ~ 1,
        FT %in% c(2,13:15) ~  2,
        TRUE ~ 0 
    )) %>%
    mutate(
      FTGCLASS= case_when(
        FTG == 30 ~ "FT-Freeways",
        FTG == 40 ~ "FT-Ramps",
        FTG == 3 ~ "FT-Minor Arterials (Urban)",
        FTG == 4 ~ "FT-Minor Arterials (Suburban)",
        FTG == 1 ~ "FT-Collectors & Locals",
        FTG == 2 ~ "FT-Principal Arterials & Expressways",
        TRUE ~ "None"
    ))
```

We now have all the groupings that we need. Below, we create various summary tables that group the travel times in different ways. We also calculate the ratios at the same time. These ratios are displayed on the Results tab.

#### 1. Previous Breakdown

```{r group0, message=FALSE, warning=FALSE}
group0_dt <- traversetime_ftg %>%
  group_by(FTGCLASS) %>%
  summarize(ModeledTimeSum = sum(ModeledTime),
            ObservedTimeSum = sum(ObservedTime)) %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  select(FTGCLASS, ratio)
group0_pkok <- traversetime_ftg %>%
  group_by(PkOk, FTGCLASS) %>%
  summarize(ModeledTimeSum = sum(ModeledTime),
            ObservedTimeSum = sum(ObservedTime)) %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  select(PkOk,FTGCLASS, ratio)
group0_pk <- group0_pkok %>%
  filter(PkOk == "pk")
group0_ok <- group0_pkok %>%
  filter(PkOk == "ok")
```


#### 2. All Functional Types, All Area Types

```{r sumtime, wanring=FALSE, message=FALSE}
group1_pkok <- traversetime_ftg %>%
  group_by(PkOk, FTCLASS, AREATYPE) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime))
group1_dt <- traversetime_ftg %>%
  group_by(FTCLASS, AREATYPE) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime)) %>%
    mutate(PkOk = "dt")
group1 <- bind_rows(group1_dt,group1_pkok) %>%
  mutate(Group = 1, GroupName = "All FT, All AT") %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  select(PkOk,FTCLASS, AREATYPE, ratio)

r_group1 <- group1 %>%
  pivot_wider(c(FTCLASS,PkOk),names_from = AREATYPE, values_from= ratio) %>%
  select(2,1,7,5,3,6,4)
```

```{r sumtime2, warning=FALSE, message=FALSE}
group2_pkok <- traversetime_ftg %>%
  group_by(PkOk, FTCLASS) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime))
group2_dt <- traversetime_ftg %>%
  group_by(FTCLASS) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime)) %>%
    mutate(PkOk = "dt")
group2 <- bind_rows(group2_dt,group2_pkok) %>%
  mutate(Group = 1, GroupName = "All FT, All AT") %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  select(PkOk,FTCLASS, ratio)

groups <- left_join(r_group1,group2) %>%
  rename("All" = ratio)
```

#### 3. Grouped Functional Types All Area Types
```{r groupagain, warning=FALSE, message=FALSE}
groupedfts <- traversetime_ftg %>%
  mutate(
      FTG2 = case_when(
        FT %in% c(1,4:10) ~ 1,       # collectors & locals
        FT == 3 ~  2,                # minor arterials
        FT == 2 ~ 3,                 # principal arterials
        FT %in% c(11:19) ~ 4,        # expressways
        FT %in% c(20:26,30:40) ~ 5,  # freeways
        FT %in% c(28:29,41:42) ~ 6,  # ramps
        TRUE ~ 0 
    )) %>%
    mutate(
      FTG2CLASS= case_when(
        FTG2 == 1 ~ "FT-Collectors & Locals",
        FTG2 == 2 ~ "FT-Minor Arterials",
        FTG2 == 3 ~ "FT-Principal Arterials",
        FTG2 == 4 ~ "FT-Expressways",
        FTG2 == 5 ~ "FT-Freeways",
        FTG2 == 6 ~ "FT-Ramps",
        TRUE ~ "None"
    ))
```

```{r sumtime3, warning=FALSE, message=FALSE}
group3_pkok <- groupedfts %>%
  group_by(PkOk, FTG2CLASS, FTG2, AREATYPE) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime))
group3_dt <- groupedfts %>%
  group_by(FTG2CLASS, FTG2, AREATYPE) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime)) %>%
    mutate(PkOk = "dt")
group3 <- bind_rows(group3_dt,group3_pkok) %>%
  mutate(Group = 3, GroupName = "Grouped FT, All AT") %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  select(PkOk,FTG2CLASS, FTG2, AREATYPE, ratio)

r_group3 <- group3 %>%
  pivot_wider(c(FTG2CLASS,FTG2,PkOk),names_from = AREATYPE, values_from= ratio) %>%
  select(2,1,3,8,4,5,6,7)
```

```{r sumtime4, warning=FALSE, message=FALSE}
group4_pkok <- groupedfts %>%
  group_by(PkOk, FTG2CLASS, FTG2) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime))
group4_dt <- groupedfts %>%
  group_by(FTG2CLASS, FTG2) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime)) %>%
    mutate(PkOk = "dt")
group4 <- bind_rows(group4_dt,group4_pkok) %>%
  mutate(Group = 3, GroupName = "Grouped FT, All AT") %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  select(PkOk,FTG2CLASS, FTG2, ratio)

groups4 <- left_join(r_group3,group4) %>%
  rename("All" = ratio)
```



## Results

### Original Breakdown
```{r originaltable, echo = FALSE, message=FALSE, warning = FALSE}
group0_compare <- left_join(df,group0_dt, by = c("FTGCLASS")) %>%
  rename("OldRatio" = "AutoSpeedRatio") %>%
  rename("NewRatio_Avg" = "ratio") %>%
  mutate(NewRatio_Avg = round(NewRatio_Avg,2)) %>%
  left_join(group0_pk) %>%
  rename("NewRatio_PK" = "ratio") %>% select(-PkOk) %>%
  left_join(group0_ok) %>%
  rename("NewRatio_OK" = "ratio") %>% select(-PkOk) %>%
  mutate(NewRatio_PK = round(NewRatio_PK,2),
         NewRatio_OK = round(NewRatio_OK,2))
kbl(group0_compare,
    caption = "Original FT Breakdown Comparison",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```


### All Functional Types All Area Types
```{r table2, echo = FALSE}
groupss <- groups %>%
  select(1,2,3,6,5,7,4,8) %>%
  rename("1-Rural" = "1", "2-Transition" = "2", "3-Suburban" = "3", "4-Urban" = "4", "5-CBD-Like" = "5") %>%
  round_df(2)

groups_dt <- groupss %>%
  filter(PkOk == "dt") %>% select(-PkOk)
groups_pk <- groupss %>%
  filter(PkOk == "pk") %>% select(-PkOk)
groups_ok <- groupss %>%
  filter(PkOk == "ok") %>% select(-PkOk)

kbl(groups_dt,
    caption = "FT Breakdown All Areatypes -- AVG",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(groups_pk,
    caption = "FT Breakdown All Areatypes -- PK",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(groups_ok,
    caption = "FT Breakdown All Areatypes -- OK",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

### Grouped Functional Types All Area Types
```{r table3, echo = FALSE}
groupss4 <- groups4 %>%
  select(-All) %>%
  rename("1-Rural" = "1", "2-Transition" = "2", "3-Suburban" = "3", "4-Urban" = "4", "5-CBD-Like" = "5") %>%
  round_df(2) %>%
  arrange(FTG2)

groups_dt4 <- groupss4 %>%
  filter(PkOk == "dt") %>% select(-PkOk)
groups_pk4 <- groupss4 %>%
  filter(PkOk == "pk") %>% select(-PkOk)
groups_ok4 <- groupss4 %>%
  filter(PkOk == "ok") %>% select(-PkOk)

kbl(groups_dt4,
    caption = "FT Group Breakdown All Areatypes -- AVG",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(groups_pk4,
    caption = "FT Group Breakdown All Areatypes -- PK",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(groups_ok4,
    caption = "FT Group Breakdown All Areatypes -- OK",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

### Looking at Ramps
All the ratios look reasonable, but the ratios related to FT-Ramps looks widely incorrect. Lets take a deeper look at where these ramps are, and why our analysis is saying the buses are traveling 1.5X faster than the auto speeds. 

```{r ramps}
tdm_ramps <- tdm_summary_all %>%
  filter(FT %in% c(41,42))

gtfsp_ramps <- gtfs_with_tdm %>%
  ungroup()%>%
  mutate(long = unlist(map(gtfs_with_tdm$midlinep,1)),
           lat = unlist(map(gtfs_with_tdm$midlinep,2))) %>%
  filter(LINKID %in% tdm_ramps$LINKID)

#gtfsl_test <- gtfs_with_tdm_lines %>%
#  filter(LabelNum == 45,
#         PkOk == period) %>%
#  st_as_sf()
```


```{r rampmap, echo = FALSE}
leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolylines(
    data = tdm_ramps$geometry,
    popup = paste("DIR: ", tdm_ramps$compass, "<br>",
                  "AM Speed: ", tdm_ramps$AM_SPD, "<br>",
                  "LINKID: ", tdm_ramps$LINKID, "<br>",
                  "LINKSEQ1: ", tdm_ramps$LINKSEQ1)
  ) %>%
  addCircleMarkers(lng = gtfsp_ramps$long, 
      lat = gtfsp_ramps$lat,
      popup = paste("DIR: ", gtfsp_ramps$compass, "<br>",
                    "AM Speed: ", gtfsp_ramps$AM_SPD, "<br>",
                    "GTFS Speed: ", gtfsp_ramps$aveSpeed, "<br>",
                    "LINKID: ", gtfsp_ramps$LINKID, "<br>",
                    "LINKSEQ1: ", gtfsp_ramps$LINKSEQ1),
      color = "red"
  ) 
#  addPolylines(
#    data = gtfsl_test$geometry,
#    popup = paste("DIR: ", gtfsl_test$compass, "<br>",
#                  "AM Speed: ", gtfsl_test$AM_SPD, "<br>",
#                  "LINKSEQ1: ", gtfsl_test$LINKID, "<br>"),
#    color = "red"
#  )
```

### Looking at Freeways

```{r freeways}
tdm_freeways <- tdm_summary_all %>%
  filter(FT %in% c(20:26,30:40))

gtfsp_freeways <- gtfs_with_tdm %>%
  ungroup()%>%
  mutate(long = unlist(map(gtfs_with_tdm$midlinep,1)),
           lat = unlist(map(gtfs_with_tdm$midlinep,2))) %>%
  filter(LINKID %in% tdm_freeways$LINKID)

#gtfsl_test <- gtfs_with_tdm_lines %>%
#  filter(LabelNum == 45,
#         PkOk == period) %>%
#  st_as_sf()
```


```{r freewaymap, echo = FALSE}
leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolylines(
    data = tdm_freeways$geometry,
    popup = paste("DIR: ", tdm_freeways$compass, "<br>",
                  "AM Speed: ", tdm_freeways$AM_SPD, "<br>",
                  "LINKID: ", tdm_freeways$LINKID, "<br>",
                  "LINKSEQ1: ", tdm_freeways$LINKSEQ1)
  ) %>%
  addCircleMarkers(lng = gtfsp_freeways$long, 
      lat = gtfsp_freeways$lat,
      popup = paste("DIR: ", gtfsp_freeways$compass, "<br>",
                    "AM Speed: ", gtfsp_freeways$AM_SPD, "<br>",
                    "GTFS Speed: ", gtfsp_freeways$aveSpeed, "<br>",
                    "LINKID: ", gtfsp_freeways$LINKID, "<br>",
                    "LINKSEQ1: ", gtfsp_freeways$LINKSEQ1),
      color = "red"
  ) 
#  addPolylines(
#    data = gtfsl_test$geometry,
#    popup = paste("DIR: ", gtfsl_test$compass, "<br>",
#                  "AM Speed: ", gtfsl_test$AM_SPD, "<br>",
#                  "LINKSEQ1: ", gtfsl_test$LINKID, "<br>"),
#    color = "red"
#  )
```

## Estimation
After reviewing the various results, we have decided to use ratios from the grouped functional classification divided by area type and period (The third set of tables labeled "Grouped Functional Types All Area Types). We have decided to ignore all ramp ratios however, and use the freeway ratios instead. This is because the ramp ratios are unrealistic and there wasn't enough data to determine those accurately .

Although we have chosen the set of tables to use for the ratios, we still need to smooth out the ratios and fill in the missing values by interpolating based on the values we currently have. 

### Step One -- Input Data
Lets get an idea of what our ratios look like plotted on a graph. This will help us get an idea of any patterns that might exist.

```{r ratios1, include = FALSE, message = FALSE, warning = FALSE}
raw_ratios <- groupss4 %>%
  rename("FTGROUP" = "FTG2CLASS") %>%
  rename("FTGNUM" = "FTG2") %>%
  filter(FTGROUP != "FT-Ramps") 
#write_csv(raw_ratios,"outputs/Estimation/raw_ratios.csv")

ratioTable <- groupss4 %>%
  filter(FTG2CLASS != "FT-Ramps")  %>%
  pivot_longer(-c(PkOk, FTG2CLASS, FTG2), names_to = "area", values_to= "ratio") %>%
  rename("FTNAME" = "FTG2CLASS") %>%
  rename("FTGROUP" = "FTG2") %>%
  rename("Ratio" = "ratio") %>%
  filter(FTGROUP != "FT-Ramps") %>%
  mutate(AreaType = case_when(
    area == "1-Rural" ~ 1,
    area == "2-Transition" ~ 2,
    area == "3-Suburban" ~ 3, 
    area == "4-Urban" ~ 4,
    area == "5-CBD-Like" ~ 5
  )) %>%
  mutate(FTGROUP = as.factor(FTGROUP)) %>%
  mutate(PkOk = ifelse(PkOk == "dt","Average",ifelse(PkOk == "pk", "Peak", "Off-Peak")))
```

```{r inputratiograph, echo = FALSE, warning=FALSE, message=FALSE}
ratioGraph <- ggplot(ratioTable) +
  aes(x = AreaType, y = Ratio, color = FTGROUP) +
  facet_wrap(~PkOk)+
  geom_point(size = 2)+ 
  scale_y_continuous( limits = c(0,1), expand = c(0,0) ) +
  theme_bw() +
  geom_line()
  #stat_smooth(method = "lm", formula = y ~ poly(x,3), se = FALSE)
ratioGraph
```

### Step Two -- PkOk Ratio of Ratios

Now that we have an idea of what the data looks like, lets start by filling in the missing off-peak points where peak points do exist. We will do this with the average ratio that exists between off-peak and peak based on functional type. Lets calculate these ratios and then fill those values in. A small table shows these ratios that may be useful for our first extrapoloation. 

```{r pkokratios, echo = FALSE, warning=FALSE, message=FALSE}
pkRatios <- ratioTable %>%
  filter(PkOk == "Peak", !is.na(AreaType)) %>%
  select(-PkOk, -area) %>%
  rename("ratioPk" = "Ratio")
okRatios <- ratioTable %>%
  filter(PkOk == "Off-Peak", !is.na(AreaType)) %>%
  rename("ratioOk" = "Ratio") %>%
  select(-area) %>%
  left_join(pkRatios, by = c("FTGROUP","AreaType")) %>%
  select(PkOk,FTGROUP,AreaType,ratioPk,ratioOk) %>%
  mutate(PkOkRatio = ratioOk/ratioPk)
okRatioAve <- okRatios %>%
  filter(!is.na(PkOkRatio)) %>%
  group_by(FTGROUP) %>%
  summarize(avePkOkRatio = mean(PkOkRatio)) %>%
  mutate(avePkOkRatio = round(avePkOkRatio,3))
kbl(okRatioAve,
    caption = "Ratio between Off-Peak and Peak Ratios by Functional Type Group",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

With these values, we can fill in a few missing points. Actually, there are only two occurrences where a peak ratio exists but an off-peak does not. This is with FT-Freeways of Areatypes 2 and 4. Lets fill those in with the calculated FR-Freeway PkOk ratio. This is done below.

```{r, echo = FALSE, warning=FALSE, message=FALSE}
ratioTable1.5 <-ratioTable %>%
  mutate(Ratio = ifelse(PkOk == "Off-Peak", ifelse(FTGROUP == 5 & AreaType == 2, 0.48,ifelse(FTGROUP == 5 & AreaType == 4, 0.62, Ratio)), Ratio))
ratioGraph15 <- ggplot(ratioTable1.5) +
  aes(x = AreaType, y = Ratio, color = FTGROUP) +
  facet_wrap(~PkOk)+
  geom_point(size = 2)+ 
  scale_y_continuous( limits = c(0,1), expand = c(0,0) ) +
  theme_bw() +
  geom_line()
ratioGraph15
```


### Step Three -- Fill in All Missing Values
Now that for all three periods (peak, off-peak, and average) all have the same missing data points, lets extrapolate the missing values based on what already exists within each period table. Lets do this by using the built in extrapolation function *na.approx* from the *zoo* package in R. After having the built in function determine the missing values, lets plot them and see how the data now looks.

```{r ratios2, echo=FALSE}
ratioTable2 <-ratioTable1.5 %>%
  group_by(FTGROUP,AreaType)  %>%
  filter(!is.na(AreaType)) %>%
  as.data.table()

ratioTable2.1 <- ratioTable2 %>%
  mutate(Ratio2 = na.approx(Ratio, rule = 2)) %>%
  mutate(Ratio2.1 = na.spline(Ratio) + 0*na.approx(Ratio, na.rm = FALSE))

ratioGraph2 <- ggplot(ratioTable2.1) +
  aes(x = AreaType, y = Ratio2, color = FTGROUP) +
  facet_wrap(~PkOk)+
  geom_point(size = 2)+ 
  scale_y_continuous( limits = c(0,1), expand = c(0,0) ) +
  theme_bw() +
  geom_line()
  #stat_smooth(method = "lm", formula = y ~ poly(x,3), se = FALSE)
ratioGraph2
```


### Step Four -- Manually Smooth Lines
Looking at result of filling in all the na values using the default R function, we see that the curves still need some smoothing out as well as some consistency between all three. As a result, this next step involves manually adjusting some values. The values that are adjusted are shown as part of the updated graph below.

```{r ratios3, include = FALSE, warning= FALSE, message = FALSE}
ratioTable3 <- ratioTable2.1 %>%
  mutate(pknum = ifelse(PkOk == "Average", 1, ifelse(PkOk == "Off-Peak", 2, 3))) %>%
  mutate(ftat = as.numeric(paste0(pknum,as.numeric(FTGROUP),AreaType))) %>%
  mutate(Ratio3 = case_when(
    # fix collectors/locals for all time periods
    ftat == 111 ~ 0.75,
    ftat == 112 ~ 0.65,
    ftat == 114 ~ 0.60,
    ftat == 311 ~ 0.76,
    ftat == 312 ~ 0.66,
    ftat == 314 ~ 0.61,
    ftat == 211 ~ 0.74,
    ftat == 212 ~ 0.64,
    ftat == 214 ~ 0.58,
    # fix principal arterials for all time periods
    ftat == 133 ~ 0.64,
    ftat == 333 ~ 0.65,
    ftat == 331 ~ 0.86,
    ftat == 233 ~ 0.59,
    ftat == 231 ~ 0.79,
    # fix minor arterials for all time periods
    ftat == 121 ~ 0.81,
    ftat == 123 ~ 0.65,
    ftat == 221 ~ 0.77,
    ftat == 225 ~ 0.5,
    ftat == 321 ~ 0.82,
    ftat == 323 ~ 0.67,
    # fix freeways for all time periods
    ftat == 153 ~ 0.7,
    ftat == 155 ~ 0.85,
    ftat == 251 ~ 0.47,
    ftat == 255 ~ 0.65,
    ftat == 353 ~ 0.71,
    ftat == 355 ~ .86,
    # fix expressways for all time periods
    ftat == 141 ~ 0.5,
    ftat == 142 ~ 0.52,
    ftat == 143 ~ 0.67,
    ftat == 144 ~ 0.77,
    ftat == 145 ~ 0.78,
    ftat == 241 ~ 0.51,
    ftat == 244 ~ 0.66,
    ftat == 245 ~ 0.67,
    ftat == 341 ~ 0.5,
    ftat == 342 ~ 0.53,
    ftat == 343 ~ 0.68,
    ftat == 344 ~ 0.77,
    ftat == 345 ~ 0.78,
    TRUE ~ Ratio2
  ))
```

```{r ratios3graph, echo = FALSE, message = FALSE, warning = FALSE}
ratios3graph <- ggplot(ratioTable3) +
  aes(x = AreaType, y = Ratio3, color = FTGROUP) +
  facet_wrap(~PkOk)+
  geom_point(size = 2)+ 
  scale_y_continuous( limits = c(0,1), expand = c(0,0) ) +
  theme_bw()
ratios3graphline <- ratios3graph  +
  geom_line()
ratios3graphline
```

### Step Five -- Mathematically Smooth Lines
Now that we have some pretty smooth lines through some manual adjustment, lets mathematically smoothen them a little more through a mathematical program. 

```{r ratios4graph, echo = FALSE, message = FALSE, warning = FALSE}
ratios4graph <- ratios3graph + stat_smooth(method = "lm", formula = y ~ poly(x,3), se = FALSE)
ratios4graph
```


```{r statsmoothdata, message = FALSE, warning = FALSE, include = FALSE}
stuff <- ggplot_build(ratios4graph)
data <- stuff[[1]][[2]]

ones<- data %>%
    group_by(group,PANEL) %>%
    slice(which.min(abs(x - 1))) %>%
    mutate(x = 1)
twos<- data %>%
    group_by(group,PANEL) %>%
    slice(which.min(abs(x - 2))) %>%
    mutate(x = 2)
threes<- data %>%
    group_by(group,PANEL) %>%
    slice(which.min(abs(x - 3))) %>%
    mutate(x = 3)
fours<- data %>%
    group_by(group,PANEL) %>%
    slice(which.min(abs(x - 4))) %>%
    mutate(x = 4)
fives<- data %>%
    group_by(group,PANEL) %>%
    slice(which.min(abs(x - 5))) %>%
    mutate(x = 5)
stat_smooth_data <- 
  bind_rows(ones,twos,threes,fours,fives) %>%
  mutate(y = round(y,2)) %>%
  mutate(FTGROUP = as.factor(group)) %>%
  mutate(PkOk = ifelse(as.numeric(PANEL) == 2, "Off-Peak", ifelse(as.numeric(PANEL) == 1, "Average", "Peak"))) %>%
  mutate(AreaType = x, Ratio4 = y) %>%
  ungroup() %>%
  select(PkOk, FTGROUP,AreaType, Ratio4)

ratioTable4 <- ratioTable3 %>%
  left_join(stat_smooth_data, by = c("PkOk", "FTGROUP", "AreaType"))

#double check that it works
ratios4graphCheck <- ggplot(ratioTable4) +
  aes(x = AreaType, y = Ratio4, color = FTGROUP) +
  facet_wrap(~PkOk)+
  geom_point(size = 2)+ 
  scale_y_continuous( limits = c(0,1), expand = c(0,0) ) +
  theme_bw() + 
  geom_line()
```

```{r, echo = FALSE, warning=FALSE, message=FALSE}
ratios4graphCheck
```

### Progress
Lets make a GIF of the progress we made!
```{r gif, include = FALSE, warning=FALSE, message=FALSE}
#animation::saveGIF(
#  expr = {
#    plot(ratioGraph)
#    plot(ratioGraph15)
#    plot(ratioGraph2)
#    plot(ratios3graphline)
#    plot(ratios4graphCheck)
#    plot(ratios4graph)
#  },
#  movie.name = "estimation_process.gif"
#)
```

![](estimation_process.gif)

### Final Estimation Table
Now that we have mathematically smoothed the data, lets take a look at the final output table. 

```{r finaltables, echo = FALSE, message = FALSE, warning = FALSE}
r_table4 <- ratioTable4 %>%
  pivot_wider(c(FTGROUP,PkOk),names_from = AreaType, values_from= Ratio4)

groups_d4 <- r_table4 %>%
  filter(PkOk == "Average") %>% select(-PkOk)
groups_p4 <- r_table4 %>%
  filter(PkOk == "Peak") %>% select(-PkOk)
groups_o4 <- r_table4 %>%
  filter(PkOk == "Off-Peak") %>% select(-PkOk)

kbl(groups_d4,
    caption = "Estimated Ratios -- FT Breakdown All Areatypes -- AVG",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(groups_p4,
    caption = "Estimated Ratios -- FT Breakdown All Areatypes -- PK",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(groups_o4,
    caption = "Estimated Ratios -- FT Breakdown All Areatypes -- OK",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```


### Write Table for TDM Model
Now that we have the final estimation table, we have to merge together the peak and off peak data and create an input table for the TDM to read. We do this below, as well as export to a csv file.

```{r, include == FALSE, message=FALSE, warning=FALSE}
names(groups_p4)[1] = ";FTGROUP"
names(groups_p4)[2] = "PK1"
names(groups_p4)[3] = "PK2"
names(groups_p4)[4] = "PK3"
names(groups_p4)[5] = "PK4"
names(groups_p4)[6] = "PK5"
names(groups_o4)[1] = ";FTGROUP"
names(groups_o4)[2] = "OK1"
names(groups_o4)[3] = "OK2"
names(groups_o4)[4] = "OK3"
names(groups_o4)[5] = "OK4"
names(groups_o4)[6] = "OK5"
finalt <- left_join(groups_p4,groups_o4)
#write_csv(finalt,"outputs/Estimation/bus_speed_ratios.csv")
```

