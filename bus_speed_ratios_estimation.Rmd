---
title: "Bus Speed Ratios Estimation"
author: "Chris Day"
date: "2022-10-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# {.tabset}

```{r libraries, warning=FALSE, message=FALSE, include=FALSE}
library(tidyverse)
library(sf)
library(gtfstools)
library(gtfs2gps)
library(leaflet)
library(hms)
library(geotidy)
library(sfheaders)
library(targets)
library(rmarkdown)
library(lwgeom)
library(nngeo)
library(foreign)
library(kableExtra)
library(zoo)
library(data.table)
library(animation)
source("R/bus_speeds_visuals.R")
source("R/bus_speeds.R")
source("R/gtfs_functions.R")
source("R/estimation_functions.R")
```

## Introduction 
### Introduction
This Rmarkdown is for estimating new traffic to bus speed ratios using traffic speeds from an output congested TDM network and GTFS bus schedule data. The traffic to bus speed ratios represent the speed ratio for which buses travel in the TDM network. In other words, compared to how fast traffic moves in the TDM, what ratio of that speed will buses travel?

### Inputs
Four main inputs are used to complete the analysis, estimation, and validation in this file. The first is a shapefile representing the spatial data of the distribution network we use to extract traffic speed data. The second is a dbf file representing transit speed data for the matching distribution network used in the shapefile. This is needed to determine which which links among all the link buses actually traverse along. The third file is an already manipulate summary dataset of gtfs speed data. The last file is a table describing the conversion between UTA, GTFS, and TDM bus routes nomenclature.

```{r inputs, message = FALSE, warning = FALSE}
tdmshpfile <- "data/TDM/Distrib_Network/Distrib_Network__Summary.shp"
transit_line_file <- "data/TDM/Distrib_Network/_v832_SE19_Net19_2_OD_Station_Detail.dbf"
gtfs_summary_data <- tar_read(speed_sums)
tdm_uta_conversion <- tar_read(tdm_uta_conversion)
```

### Current Ratios
The current ratios being used to determining TDM bus travel speeds are as follows:

```{r currentratios, echo=FALSE}
df <- data.frame (FTGCLASS  = c("FT-Freeways", "FT-Ramps", "FT-Principal Arterials & Expressways", "FT-Minor Arterials (Urban)", "FT-Minor Arterials (Suburban)", "FT-Collectors & Locals"),
                  AutoSpeedRatio = c(.95, 0.75, 0.60, 0.55, 0.65, 0.60))
kbl(df) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

*minimum bus speed = 10mph

As seen in the table, ratios are constant for all buses of the same functional class (except for minor arterials where it varies by area type as well). Similarly, part of our process will be to analyze how different functional classes and area types affect the speed ratios. 

For more information on the GTFS data, or other data that could have been used in this estimation, please refer to the bus_speeds.R and gtfs_bus_speeds.rmd files within the project directory. Within those validation scripts, we determined that GTFS data was a more stable dataset for estimation purposes.

### Process for Estimation
The data munging required for estimation is slightly complicated, and so the outlined process is explained in the following steps.

  - *STEP 1*: Match the congested traffic speed, functional class, and area type of the nearest TDM link to each GTFS link. 
  
      a. Determine period (peak/off-peak) and compass direction (NB,SB,EB,WB) for all TDM links and GTFS links
      
      b. Join TDM speed attributes to GTFS links by period and compass direction
      
      c. Delete all GTFS links that were unable to match with a TDM link or matched with a link way too far away.
      
  - *STEP 2*: Using the GTFS link distance and the TDM speed, calculate the modeled link travel traverse time. Also calculate the GTFS observed link travel traverse time.
  
  - *STEP 3*: Calculate the cumulative link travel traverse time for both observed and modeled data by summing together travel times by period and functional classification and area type.
  
  - *STEP 4*: Calculate the congested speed to bus speed ratio by dividing the cumulative travel traverse times. Do this by period and functional classification and area type. 
  
      a. Also do this where area type is not accounted for.
    
      b. Also do this where period is not acounted for.

## Analysis
### Analysis
In this section, we run through the 4 steps described in the introduction. This will allow us to compare TDM congested speeds with GTFS data points. We compare these two datasets and create summary tables to decide which grouping set we should use for ratio estimation.

### Step 1 - Prepare TDM Data
Before matching TDM attributes to the GTFS link, we need to prepare the TDM data. First, we read in the Distribution Network Link SHP with the needed attributes. 
  
```{r tdmprep, warning=FALSE, message=FALSE}
tdmlinkshp <- st_read(tdmshpfile, quiet = TRUE) %>%
  select(LINKID, FT, FTCLASS, AREATYPE, DIRECTION, AM_SPD, MD_SPD, geometry, ATYPENAME, ATYPEGRP, PM_SPD, EV_SPD, EV_SPD, DY_SPD)
paged_table(tdmlinkshp)
```

After reading in the SHP data, we need to filter the link dataset to only include those links that correspond to bus routes. We also need to attach the route id to each link. We do this below.

```{r tdmroutes, warning=FALSE,message=FALSE}
tdm_link_shp_attributes <- tdmlinkshp  %>% as_tibble()

tdm_summary_all <- read.dbf(transit_line_file) %>%
  group_by(MODE,NAME,NAMEID) %>%
  mutate(B = lead(A)) %>%
  select(MODE,NAMEID,NAME,ONEWAY,LINKSEQ1,LINKSEQ2,A,B,STOPS,DIST) %>%
  mutate(LINKID = paste0(A,"_",B)) %>%
  left_join(tdm_link_shp_attributes) %>%
  filter(!is.na(FT)) %>%
  left_join(tdm_uta_conversion, by = c("NAME"="TDMRoute")) %>%
  select(-UTARoute,-Notes,-GTFSRoute) %>%
  mutate(compass = DIRECTION) %>%
  st_as_sf(crs = 26912) %>%
  st_transform(4326)
```

### Step 1 - Prepare GTFS Data
The input TDM link shapefile already has link id, functional class, areatype, compass direction, and peak and off-peak speeds so no more manipulation is needed to prepare that input. Now, we read in the GTFS data of corresponding attributes. In the gtfs_bus_speeds.Rmd and gtfs_functions.R, a lot of data munging has already been completed, so we read in the partially manipulated GTFS data.

```{r gtfsprep}
#also read in inputs section
gtfs_summary_data <- tar_read(speed_sums)
```

This gtfs summary data is composed of polylines, instead of individual line segments. For this analysis however, we want to keep it as polylines. The summary data still needs some munging though. We still need to add compass direction, convert to the correct units, and add common route labeling. We do this below.

```{r gtfsmung}
gtfs_summary_compass <- gtfs_summary_data %>% 
  mutate(startpoint = st_startpoint(geometry),
         endpoint = st_endpoint(geometry)) %>%
  mutate(azimuth = st_azimuth(startpoint,endpoint)) %>%
  mutate(compass = ifelse(azimuth > 315 | azimuth <= 45, "NB",
                   ifelse(azimuth > 45 & azimuth <= 135, "EB",
                   ifelse(azimuth > 135 & azimuth <= 225, "SB",
                   ifelse(azimuth > 225 & azimuth <= 315, "WB", NA))))
         ) %>%
  mutate(aveSpeed = as.numeric(aveSpeed) * 0.621371,
         aveDistance = as.numeric(aveDistance)* 0.000621371) %>%
  as_tibble() %>%
  left_join(tdm_uta_conversion, by = c("route_short_name" = "GTFSRoute")) %>%
  select(-Notes,-UTARoute,-TDMRoute) %>%
  st_as_sf()

gtfs_summary_all <- gtfs_summary_compass %>%
  select(-startpoint,-endpoint) %>%
  group_by(route_short_name,PkOk,direction_id) %>%
  mutate(rownum = row_number()) %>%
  mutate(uniquerow = paste0(route_short_name,PkOk,direction_id,rownum))
```

To double check that the compass direction look good lets take a look at route 11. 

```{r filterroutes, message=FALSE, warning=FALSE, include=FALSE}
route <- "11"
period <- "pk"
gtfs_summary_all_filtered <- gtfs_summary_all %>%
  filter(route_short_name == route,
         PkOk == period) 
uta_gps_points_filtered <- tar_read(stop_locations) %>%
  filter(route_short_name == route,
         PkOk == period) 
```

```{r route11map, echo = FALSE}
leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolylines(
    data = gtfs_summary_all_filtered$geometry,
    popup = paste("DIR:", gtfs_summary_all_filtered$compass, "<br>",
                  "Angle", gtfs_summary_all_filtered$azimuth, "<br>",
                  "Ave Speed", gtfs_summary_all_filtered$aveSpeed, "<br>",
                  "Dist", gtfs_summary_all_filtered$aveDistance,"<br>",
                  "stop_seq", gtfs_summary_all_filtered$stop_sequence)
  ) %>%
  addCircleMarkers(lng = uta_gps_points_filtered$long, 
      lat = uta_gps_points_filtered$lat,
      popup = paste("stop_seq", uta_gps_points_filtered$stop_sequence),
      color = "red")
  #addCircleMarkers(lng = gtfs_cf$long, lat = gtfs_cf$lat,
  #                 color = "Blue")
```

### Step 1- Combine TDM and GTFS Data
Now that both TDM and GTFS spatial objects contain the correct information, we are almost ready to merge the TDM speed data to the GTFS links. First, we create a centroid object for all the GTFS polylines. These centroids will be used to find the closest TDM link to that GTFS polyline. 

```{r gtfscentroids, warning=FALSE, message=FALSE}
gtfs_summary_centroids <- gtfs_summary_all %>% make_centerpoint() %>%
  st_as_sf(crs = 26912) %>%
  st_transform(4326)

gtfs_cf <- gtfs_summary_centroids %>%
  mutate(long = unlist(map(gtfs_summary_centroids$midlinep,1)),
           lat = unlist(map(gtfs_summary_centroids$midlinep,2))) %>%
  filter(route_short_name == route,
         PkOk == period) 
```

Now that we have a centroid object, we can match the closest TDM link to each GTFS centroid. That centroid object will then take on all the TDM attributes. We then merge those attribute back onto the GTFS link object! 

```{r gtfstdmjoin}
gtfs_with_tdm <- join_to_gtfs(tdm_summary_all,gtfs_summary_centroids) %>%
  select(-Label.1, -LabelNum.1, -compass.1)

gtfs_with_tdm_short <- gtfs_with_tdm %>%
  select(LINKID, centroid_id,FT,FTCLASS,AREATYPE,AM_SPD,MD_SPD,dist, uniquerow) %>%
  as_tibble() %>% select(-midlinep)

gtfs_with_tdm_lines <- gtfs_summary_all %>%
  left_join(gtfs_with_tdm_short, by = c("uniquerow")) 
```

Now that we have GTFS links with TDM attributes, lets make a map to verify that our process worked correctly. Below is a map of the GTFS centroids and GTFS links (red) alongside the TDM links (blue). 

```{r joinmaptest, include = FALSE}
labelnum <- 45
period <- "pk"

tdm_test <- tdm_summary_all %>%
  filter(LabelNum == 45) %>%
  st_as_sf()
gtfsp_test <- gtfs_with_tdm %>%
    ungroup()%>%
  mutate(long = unlist(map(gtfs_with_tdm$midlinep,1)),
           lat = unlist(map(gtfs_with_tdm$midlinep,2))) %>%
  filter(LabelNum == 45,
         PkOk == period)
gtfsl_test <- gtfs_with_tdm_lines %>%
  filter(LabelNum == 45,
         PkOk == period) %>%
  st_as_sf()
```

```{r jointmaptest, echo = FALSE}
leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolylines(
    data = tdm_test$geometry,
    popup = paste("DIR: ", tdm_test$compass, "<br>",
                  "AM Speed: ", tdm_test$AM_SPD, "<br>",
                  "LINKID: ", tdm_test$LINKID, "<br>",
                  "LINKSEQ1: ", tdm_test$LINKSEQ1)
  ) %>%
  addCircleMarkers(lng = gtfsp_test$long, 
      lat = gtfsp_test$lat,
      popup = paste("DIR: ", gtfsp_test$compass, "<br>",
                    "AM Speed: ", gtfsp_test$AM_SPD, "<br>",
                    "LINKID: ", gtfsp_test$LINKID, "<br>",
                    "LINKSEQ1: ", gtfsp_test$LINKSEQ1),
      color = "red"
  ) %>%
  addPolylines(
    data = gtfsl_test$geometry,
    popup = paste("DIR: ", gtfsl_test$compass, "<br>",
                  "AM Speed: ", gtfsl_test$AM_SPD, "<br>",
                  "LINKSEQ1: ", gtfsl_test$LINKID, "<br>"),
    color = "red"
  )
```

### Step 1 - Delete Unreasonable or Mismatched Data
In some cases, when doing the matching process some GTFS links were not matched with a TDM link. Therefore, there are some GTFS links with empty values. We must filter those out before calculating the ratios. There are also GTFS links that did get TDM attributes, but the distance at which they received data is unreasonably far. Therefore, we must also filter out any link that received TDM data from too far away. Lastly, some of the GTFS speed calculations were not perfect. So in addition, we filter out any speed calculation that doesn't make sense (i.e. a bus speed traveling 50mph faster or slower than actual road speeds). The distance and speed filter is based on arbitrary numbers, and can be changed later on if these ones don't make sense.

```{r}
gtfs_with_tdm_clean <- clean_gtfs_joint_data(gtfs_with_tdm_lines, 30, 2500)
```

### Step 2 - Link Travel Traverse Time
Now that we have a dataset of all the GTFS links with TDM speed data, we need to calculate the modeled link traverse time using the GTFS distance. The GTFS link traverse time has already been calculated. This step is completed below.

```{r traversetime}
traversetime <- gtfs_with_tdm_clean %>%
  mutate(ModeledTime = aveDistance / Modeled * 3600, 
         ObservedTime = aveDistance / Observed * 3600)
```

### Step 3 & 4 - Cumulative Link Travel Traverse Time
Now that we have link traverse time for modeled and observed, we can calculate the summed traverse time by period and functional classificiation and area type. Before doing this however, we need to create the option to group the functional types together by the existing groupings. This is done below.

```{r ftg}
traversetime_ftg <- traversetime %>%
  as_tibble() %>% select(-geometry) %>%
  mutate(
      FTG = case_when(
        FT %in% c(20:26,30:40) ~ 30,
        FT %in% c(28:29,41:42) ~ 40,
        FT == 3 & AREATYPE %in% c(4,5) ~ 3,
        FT == 3  & AREATYPE %in% c(1,2,3) ~ 4,
        FT %in% c(1,4:8) ~ 1,
        FT %in% c(2,13:15) ~  2,
        TRUE ~ 0 
    )) %>%
    mutate(
      FTGCLASS= case_when(
        FTG == 30 ~ "FT-Freeways",
        FTG == 40 ~ "FT-Ramps",
        FTG == 3 ~ "FT-Minor Arterials (Urban)",
        FTG == 4 ~ "FT-Minor Arterials (Suburban)",
        FTG == 1 ~ "FT-Collectors & Locals",
        FTG == 2 ~ "FT-Principal Arterials & Expressways",
        TRUE ~ "None"
    ))
```

We now have all the groupings that we need. Below, we create various summary tables that group the travel times in different ways. We also calculate the ratios at the same time. These ratios are displayed on the Results tab.

#### 1. Previous Breakdown
The first summary table that we want to create is a comparison between old ratios and new ratios -- in other words, the code below summarizes the data and calculated ratios for the exact same groupings used before.

```{r group0, message=FALSE, warning=FALSE}
group0_dt <- traversetime_ftg %>%
  group_by(FTGCLASS) %>%
  summarize(ModeledTimeSum = sum(ModeledTime),
            ObservedTimeSum = sum(ObservedTime)) %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  select(FTGCLASS, ratio)
group0_pkok <- traversetime_ftg %>%
  group_by(PkOk, FTGCLASS) %>%
  summarize(ModeledTimeSum = sum(ModeledTime),
            ObservedTimeSum = sum(ObservedTime)) %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  select(PkOk,FTGCLASS, ratio)
group0_pk <- group0_pkok %>%
  filter(PkOk == "pk")
group0_ok <- group0_pkok %>%
  filter(PkOk == "ok")
```


#### 2. All Functional Types, All Area Types
The next grouping is for all functional types and all area types. Every single FT value is separate as well as area type.

```{r sumtime, wanring=FALSE, message=FALSE}
group1_pkok <- traversetime_ftg %>%
  group_by(PkOk, FTCLASS, AREATYPE) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime))
group1_dt <- traversetime_ftg %>%
  group_by(FTCLASS, AREATYPE) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime)) %>%
    mutate(PkOk = "dt")
group1 <- bind_rows(group1_dt,group1_pkok) %>%
  mutate(Group = 1, GroupName = "All FT, All AT") %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  select(PkOk,FTCLASS, AREATYPE, ratio)

r_group1 <- group1 %>%
  pivot_wider(c(FTCLASS,PkOk),names_from = AREATYPE, values_from= ratio) %>%
  select(2,1,7,5,3,6,4)
```

```{r sumtime2, warning=FALSE, message=FALSE}
group2_pkok <- traversetime_ftg %>%
  group_by(PkOk, FTCLASS) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime))
group2_dt <- traversetime_ftg %>%
  group_by(FTCLASS) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime)) %>%
    mutate(PkOk = "dt")
group2 <- bind_rows(group2_dt,group2_pkok) %>%
  mutate(Group = 1, GroupName = "All FT, All AT") %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  select(PkOk,FTCLASS, ratio)

groups <- left_join(r_group1,group2) %>%
  rename("All" = ratio)
```

#### 3. Grouped Functional Types All Area Types
The last grouping we do is dividing up into 6 groups, as shown between. It's similar to the previous grouping except centroid connectors and collectors are grouped together. 

```{r groupagain, warning=FALSE, message=FALSE}
groupedfts <- traversetime_ftg %>%
  mutate(
      FTG2 = case_when(
        FT %in% c(1,4:10) ~ 1,       # collectors & locals
        FT == 3 ~  2,                # minor arterials
        FT == 2 ~ 3,                 # principal arterials
        FT %in% c(11:19) ~ 4,        # expressways
        FT %in% c(20:26,30:40) ~ 5,  # freeways
        FT %in% c(28:29,41:42) ~ 6,  # ramps
        TRUE ~ 0 
    )) %>%
    mutate(
      FTG2CLASS= case_when(
        FTG2 == 1 ~ "FT-Collectors & Locals",
        FTG2 == 2 ~ "FT-Minor Arterials",
        FTG2 == 3 ~ "FT-Principal Arterials",
        FTG2 == 4 ~ "FT-Expressways",
        FTG2 == 5 ~ "FT-Freeways",
        FTG2 == 6 ~ "FT-Ramps",
        TRUE ~ "None"
    ))
```

```{r sumtime3, warning=FALSE, message=FALSE}
group3_pkok <- groupedfts %>%
  group_by(PkOk, FTG2CLASS, FTG2, AREATYPE) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime))
group3_dt <- groupedfts %>%
  group_by(FTG2CLASS, FTG2, AREATYPE) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime)) %>%
    mutate(PkOk = "dt")
group3 <- bind_rows(group3_dt,group3_pkok) %>%
  mutate(Group = 3, GroupName = "Grouped FT, All AT") %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  select(PkOk,FTG2CLASS, FTG2, AREATYPE, ratio)

r_group3 <- group3 %>%
  pivot_wider(c(FTG2CLASS,FTG2,PkOk),names_from = AREATYPE, values_from= ratio) %>%
  select(2,1,3,8,4,5,6,7)
```

```{r sumtime4, warning=FALSE, message=FALSE}
group4_pkok <- groupedfts %>%
  group_by(PkOk, FTG2CLASS, FTG2) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime))
group4_dt <- groupedfts %>%
  group_by(FTG2CLASS, FTG2) %>%
    summarize(ModeledTimeSum = sum(ModeledTime),
              ObservedTimeSum = sum(ObservedTime)) %>%
    mutate(PkOk = "dt")
group4 <- bind_rows(group4_dt,group4_pkok) %>%
  mutate(Group = 3, GroupName = "Grouped FT, All AT") %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  select(PkOk,FTG2CLASS, FTG2, ratio)

groups4 <- left_join(r_group3,group4) %>%
  rename("All" = ratio)
```

## Ratio Table Options
### Ratio Table Options
In this section, we look at the calculated ratio tables for the three different groupings we created in the Analysis section. As a reminder, the three different groupings are original breakdown, all functional types and all area types, and grouped functional types and all area types.

### Original Breakdown
Below is the table comparing the old ratio value with the average, peak, and off peak ratio value we just calculated. As you can see, many of these values are pretty close except for ramps and freeways. Ramps clearly is way off in our new calculation, and freeways is much lower than expected.

```{r originaltable, echo = FALSE, message=FALSE, warning = FALSE}
group0_compare <- left_join(df,group0_dt, by = c("FTGCLASS")) %>%
  rename("OldRatio" = "AutoSpeedRatio") %>%
  rename("NewRatio_Avg" = "ratio") %>%
  mutate(NewRatio_Avg = round(NewRatio_Avg,2)) %>%
  left_join(group0_pk) %>%
  rename("NewRatio_PK" = "ratio") %>% select(-PkOk) %>%
  left_join(group0_ok) %>%
  rename("NewRatio_OK" = "ratio") %>% select(-PkOk) %>%
  mutate(NewRatio_PK = round(NewRatio_PK,2),
         NewRatio_OK = round(NewRatio_OK,2))
kbl(group0_compare,
    caption = "Original FT Breakdown Comparison",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

### All Functional Types All Area Types
The following tables show the ratios calculated without first grouping the functional types. A lot can be seen here, but a few observations are that ramps are way off and freeways are lower than expected. 

```{r table2, echo = FALSE}
groupss <- groups %>%
  select(1,2,3,6,5,7,4,8) %>%
  rename("1-Rural" = "1", "2-Transition" = "2", "3-Suburban" = "3", "4-Urban" = "4", "5-CBD-Like" = "5") %>%
  round_df(2)

groups_dt <- groupss %>%
  filter(PkOk == "dt") %>% select(-PkOk)
groups_pk <- groupss %>%
  filter(PkOk == "pk") %>% select(-PkOk)
groups_ok <- groupss %>%
  filter(PkOk == "ok") %>% select(-PkOk)

kbl(groups_dt,
    caption = "FT Breakdown All Areatypes -- AVG",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(groups_pk,
    caption = "FT Breakdown All Areatypes -- PK",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(groups_ok,
    caption = "FT Breakdown All Areatypes -- OK",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

### Grouped Functional Types All Area Types
The last ratio table set we present are with grouped functional types. Looking at these values, we believe these are the next step in the bus speed ratio process. Excluding the ramp ratios, the other groupings seem to make sense. It would also make sense to separate by period, because it seems peak and off-peak are different enough. 

```{r table3, echo = FALSE}
groupss4 <- groups4 %>%
  select(-All) %>%
  rename("1-Rural" = "1", "2-Transition" = "2", "3-Suburban" = "3", "4-Urban" = "4", "5-CBD-Like" = "5") %>%
  round_df(2) %>%
  arrange(FTG2)

groups_dt4 <- groupss4 %>%
  filter(PkOk == "dt") %>% select(-PkOk)
groups_pk4 <- groupss4 %>%
  filter(PkOk == "pk") %>% select(-PkOk)
groups_ok4 <- groupss4 %>%
  filter(PkOk == "ok") %>% select(-PkOk)

kbl(groups_dt4,
    caption = "FT Group Breakdown All Areatypes -- AVG",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(groups_pk4,
    caption = "FT Group Breakdown All Areatypes -- PK",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(groups_ok4,
    caption = "FT Group Breakdown All Areatypes -- OK",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

Since we have decided to use these tables as a starting point, we still need to estimate the missing values, and smooth out the estimation. This is done on the estimation tab.

## Estimation
### Estimation
After reviewing the various ratio table options, we have decided to use ratios from the grouped functional classification divided by area type and period (The third set of tables labeled "Grouped Functional Types All Area Types"). We have decided to ignore all ramp ratios however, and use the freeway ratios instead. This is because the ramp ratios are unrealistic and there wasn't enough data to determine those accurately .

Although we have chosen the set of tables to use for the ratios, we still need to smooth out the ratios and fill in the missing values by interpolating based on the values we currently have. 

### Step One -- Input Data
Lets get an idea of what our ratios look like plotted on a graph. This will help us get an idea of any patterns that might exist.

```{r ratios1, include = FALSE, message = FALSE, warning = FALSE}
raw_ratios <- groupss4 %>%
  rename("FTGROUP" = "FTG2CLASS") %>%
  rename("FTGNUM" = "FTG2") %>%
  filter(FTGROUP != "FT-Ramps") 
#write_csv(raw_ratios,"outputs/Estimation/raw_ratios.csv")

ratioTable <- groupss4 %>%
  filter(FTG2CLASS != "FT-Ramps")  %>%
  pivot_longer(-c(PkOk, FTG2CLASS, FTG2), names_to = "area", values_to= "ratio") %>%
  rename("FTNAME" = "FTG2CLASS") %>%
  rename("FTGROUP" = "FTG2") %>%
  rename("Ratio" = "ratio") %>%
  filter(FTGROUP != "FT-Ramps") %>%
  mutate(AreaType = case_when(
    area == "1-Rural" ~ 1,
    area == "2-Transition" ~ 2,
    area == "3-Suburban" ~ 3, 
    area == "4-Urban" ~ 4,
    area == "5-CBD-Like" ~ 5
  )) %>%
  mutate(FTGROUP = as.factor(FTGROUP)) %>%
  mutate(PkOk = ifelse(PkOk == "dt","Average",ifelse(PkOk == "pk", "Peak", "Off-Peak")))
```

```{r inputratiograph, echo = FALSE, warning=FALSE, message=FALSE}
ratioGraph <- ggplot(ratioTable) +
  aes(x = AreaType, y = Ratio, color = FTGROUP) +
  facet_wrap(~PkOk)+
  geom_point(size = 2)+ 
  scale_y_continuous( limits = c(0,1), expand = c(0,0) ) +
  theme_bw() +
  geom_line()
  #stat_smooth(method = "lm", formula = y ~ poly(x,3), se = FALSE)
ratioGraph
```

### Step Two -- PkOk Ratio of Ratios

Now that we have an idea of what the data looks like, lets start by filling in the missing off-peak points where peak points do exist. We will do this with the average ratio that exists between off-peak and peak based on functional type. Lets calculate these ratios and then fill those values in. A small table shows these ratios that may be useful for our first extrapoloation. 

```{r pkokratios, echo = FALSE, warning=FALSE, message=FALSE}
pkRatios <- ratioTable %>%
  filter(PkOk == "Peak", !is.na(AreaType)) %>%
  select(-PkOk, -area) %>%
  rename("ratioPk" = "Ratio")
okRatios <- ratioTable %>%
  filter(PkOk == "Off-Peak", !is.na(AreaType)) %>%
  rename("ratioOk" = "Ratio") %>%
  select(-area) %>%
  left_join(pkRatios, by = c("FTGROUP","AreaType")) %>%
  select(PkOk,FTGROUP,AreaType,ratioPk,ratioOk) %>%
  mutate(PkOkRatio = ratioOk/ratioPk)
okRatioAve <- okRatios %>%
  filter(!is.na(PkOkRatio)) %>%
  group_by(FTGROUP) %>%
  summarize(avePkOkRatio = mean(PkOkRatio)) %>%
  mutate(avePkOkRatio = round(avePkOkRatio,3))
kbl(okRatioAve,
    caption = "Ratio between Off-Peak and Peak Ratios by Functional Type Group",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

With these values, we can fill in a few missing points. Actually, there are only two occurrences where a peak ratio exists but an off-peak does not. This is with FT-Freeways of Areatypes 2 and 4. Lets fill those in with the calculated FR-Freeway PkOk ratio. This is done below.

```{r, echo = FALSE, warning=FALSE, message=FALSE}
ratioTable1.5 <-ratioTable %>%
  mutate(Ratio = ifelse(PkOk == "Off-Peak", ifelse(FTGROUP == 5 & AreaType == 2, 0.48,ifelse(FTGROUP == 5 & AreaType == 4, 0.62, Ratio)), Ratio))
ratioGraph15 <- ggplot(ratioTable1.5) +
  aes(x = AreaType, y = Ratio, color = FTGROUP) +
  facet_wrap(~PkOk)+
  geom_point(size = 2)+ 
  scale_y_continuous( limits = c(0,1), expand = c(0,0) ) +
  theme_bw() +
  geom_line()
ratioGraph15
```


### Step Three -- Fill in All Missing Values
Now that for all three periods (peak, off-peak, and average) all have the same missing data points, lets extrapolate the missing values based on what already exists within each period table. Lets do this by using the built in extrapolation function *na.approx* from the *zoo* package in R. After having the built in function determine the missing values, lets plot them and see how the data now looks.

```{r ratios2, echo=FALSE}
ratioTable2 <-ratioTable1.5 %>%
  group_by(FTGROUP,AreaType)  %>%
  filter(!is.na(AreaType)) %>%
  as.data.table()

ratioTable2.1 <- ratioTable2 %>%
  mutate(Ratio2 = na.approx(Ratio, rule = 2)) %>%
  mutate(Ratio2.1 = na.spline(Ratio) + 0*na.approx(Ratio, na.rm = FALSE))

ratioGraph2 <- ggplot(ratioTable2.1) +
  aes(x = AreaType, y = Ratio2, color = FTGROUP) +
  facet_wrap(~PkOk)+
  geom_point(size = 2)+ 
  scale_y_continuous( limits = c(0,1), expand = c(0,0) ) +
  theme_bw() +
  geom_line()
  #stat_smooth(method = "lm", formula = y ~ poly(x,3), se = FALSE)
ratioGraph2
```


### Step Four -- Manually Smooth Lines
Looking at result of filling in all the na values using the default R function, we see that the curves still need some smoothing out as well as some consistency between all three. As a result, this next step involves manually adjusting some values. The values that are adjusted are shown as part of the updated graph below.

```{r ratios3, include = FALSE, warning= FALSE, message = FALSE}
ratioTable3 <- ratioTable2.1 %>%
  mutate(pknum = ifelse(PkOk == "Average", 1, ifelse(PkOk == "Off-Peak", 2, 3))) %>%
  mutate(ftat = as.numeric(paste0(pknum,as.numeric(FTGROUP),AreaType))) %>%
  mutate(Ratio3 = case_when(
    # fix collectors/locals for all time periods
    ftat == 111 ~ 0.75,
    ftat == 112 ~ 0.65,
    ftat == 114 ~ 0.60,
    ftat == 311 ~ 0.76,
    ftat == 312 ~ 0.66,
    ftat == 314 ~ 0.61,
    ftat == 211 ~ 0.74,
    ftat == 212 ~ 0.64,
    ftat == 214 ~ 0.58,
    # fix principal arterials for all time periods
    ftat == 133 ~ 0.64,
    ftat == 333 ~ 0.65,
    ftat == 331 ~ 0.86,
    ftat == 233 ~ 0.59,
    ftat == 231 ~ 0.79,
    # fix minor arterials for all time periods
    ftat == 121 ~ 0.81,
    ftat == 123 ~ 0.65,
    ftat == 221 ~ 0.77,
    ftat == 225 ~ 0.5,
    ftat == 321 ~ 0.82,
    ftat == 323 ~ 0.67,
    # fix freeways for all time periods
    ftat == 153 ~ 0.7,
    ftat == 155 ~ 0.85,
    ftat == 251 ~ 0.47,
    ftat == 255 ~ 0.65,
    ftat == 353 ~ 0.71,
    ftat == 355 ~ .86,
    # fix expressways for all time periods
    ftat == 141 ~ 0.5,
    ftat == 142 ~ 0.52,
    ftat == 143 ~ 0.67,
    ftat == 144 ~ 0.77,
    ftat == 145 ~ 0.78,
    ftat == 241 ~ 0.51,
    ftat == 244 ~ 0.66,
    ftat == 245 ~ 0.67,
    ftat == 341 ~ 0.5,
    ftat == 342 ~ 0.53,
    ftat == 343 ~ 0.68,
    ftat == 344 ~ 0.77,
    ftat == 345 ~ 0.78,
    TRUE ~ Ratio2
  ))
```

```{r ratios3graph, echo = FALSE, message = FALSE, warning = FALSE}
ratios3graph <- ggplot(ratioTable3) +
  aes(x = AreaType, y = Ratio3, color = FTGROUP) +
  facet_wrap(~PkOk)+
  geom_point(size = 2)+ 
  scale_y_continuous( limits = c(0,1), expand = c(0,0) ) +
  theme_bw()
ratios3graphline <- ratios3graph  +
  geom_line()
ratios3graphline
```

### Step Five -- Mathematically Smooth Lines
Now that we have some pretty smooth lines through some manual adjustment, lets mathematically smoothen them a little more through a mathematical program. 

```{r ratios4graph, echo = FALSE, message = FALSE, warning = FALSE}
ratios4graph <- ratios3graph + stat_smooth(method = "lm", formula = y ~ poly(x,3), se = FALSE)
ratios4graph
```


```{r statsmoothdata, message = FALSE, warning = FALSE, include = FALSE}
stuff <- ggplot_build(ratios4graph)
data <- stuff[[1]][[2]]

ones<- data %>%
    group_by(group,PANEL) %>%
    slice(which.min(abs(x - 1))) %>%
    mutate(x = 1)
twos<- data %>%
    group_by(group,PANEL) %>%
    slice(which.min(abs(x - 2))) %>%
    mutate(x = 2)
threes<- data %>%
    group_by(group,PANEL) %>%
    slice(which.min(abs(x - 3))) %>%
    mutate(x = 3)
fours<- data %>%
    group_by(group,PANEL) %>%
    slice(which.min(abs(x - 4))) %>%
    mutate(x = 4)
fives<- data %>%
    group_by(group,PANEL) %>%
    slice(which.min(abs(x - 5))) %>%
    mutate(x = 5)
stat_smooth_data <- 
  bind_rows(ones,twos,threes,fours,fives) %>%
  mutate(y = round(y,2)) %>%
  mutate(FTGROUP = as.factor(group)) %>%
  mutate(PkOk = ifelse(as.numeric(PANEL) == 2, "Off-Peak", ifelse(as.numeric(PANEL) == 1, "Average", "Peak"))) %>%
  mutate(AreaType = x, Ratio4 = y) %>%
  ungroup() %>%
  select(PkOk, FTGROUP,AreaType, Ratio4)

ratioTable4 <- ratioTable3 %>%
  left_join(stat_smooth_data, by = c("PkOk", "FTGROUP", "AreaType"))

#double check that it works
ratios4graphCheck <- ggplot(ratioTable4) +
  aes(x = AreaType, y = Ratio4, color = FTGROUP) +
  facet_wrap(~PkOk)+
  geom_point(size = 2)+ 
  scale_y_continuous( limits = c(0,1), expand = c(0,0) ) +
  theme_bw() + 
  geom_line()
```

```{r, echo = FALSE, warning=FALSE, message=FALSE}
ratios4graphCheck
```

### Step Six -- Final Ratios
In this last step, we make just a few adjustments to the mathematically smooth line ratios, to ensure a coherent slope/change between area types of the same functional groupings. These changes are made below, and represent the final ratios to be used.

```{r, message = FALSE, warning = FALSE, include = FALSE}
ratioTable5 <- ratioTable4 %>%
  mutate(Ratio5 = case_when(
    ftat == 151 ~ .61,
    ftat == 144 ~ .76,
    ftat == 145 ~ 0.79,
    ftat == 251 ~ .46,
    ftat == 252 ~ .47,
    ftat == 255 ~ .64,
    ftat == 245 ~ .69,
    ftat == 351 ~ .61,
    ftat == 344 ~ .76,
    ftat == 345 ~ .79,
    TRUE ~ Ratio4
  ))
```

```{r, echo = FALSE, warning=FALSE, message=FALSE}
ratios5graph <- ggplot(ratioTable5) +
  aes(x = AreaType, y = Ratio5, color = FTGROUP) +
  facet_wrap(~PkOk)+
  geom_point(size = 2)+ 
  scale_y_continuous( limits = c(0,1), expand = c(0,0) ) +
  theme_bw() + 
  geom_line()
ratios5graph
```




### Progress
Lets make a GIF of the progress we made!
```{r gif, include = FALSE, warning=FALSE, message=FALSE}
#animation::saveGIF(
#  expr = {
#    plot(ratioGraph)
#    plot(ratioGraph15)
#    plot(ratioGraph2)
#    plot(ratios3graphline)
#    plot(ratios4graphCheck)
#    plot(ratios5graph)
#  },
#  movie.name = "estimation_process.gif"
#)
```

![](estimation_process.gif)

### Final Estimation Table
Now that we have mathematically smoothed the data, lets take a look at the final output table. 

```{r finaltables, echo = FALSE, message = FALSE, warning = FALSE}
r_table4 <- ratioTable5 %>%
  pivot_wider(c(FTGROUP,PkOk),names_from = AreaType, values_from= Ratio5)

groups_d4 <- r_table4 %>%
  filter(PkOk == "Average") %>% select(-PkOk)
groups_p4 <- r_table4 %>%
  filter(PkOk == "Peak") %>% select(-PkOk)
groups_o4 <- r_table4 %>%
  filter(PkOk == "Off-Peak") %>% select(-PkOk)

kbl(groups_d4,
    caption = "Estimated Ratios -- FT Breakdown All Areatypes -- AVG",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(groups_p4,
    caption = "Estimated Ratios -- FT Breakdown All Areatypes -- PK",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(groups_o4,
    caption = "Estimated Ratios -- FT Breakdown All Areatypes -- OK",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```


### Write Table for TDM Model
Now that we have the final estimation table, we have to merge together the peak and off peak data and create an input table for the TDM to read. We do this below, as well as export to a csv file.

```{r, include == FALSE, message=FALSE, warning=FALSE}
names(groups_p4)[1] = ";FTGROUP"
names(groups_p4)[2] = "PK1"
names(groups_p4)[3] = "PK2"
names(groups_p4)[4] = "PK3"
names(groups_p4)[5] = "PK4"
names(groups_p4)[6] = "PK5"
names(groups_o4)[1] = ";FTGROUP"
names(groups_o4)[2] = "OK1"
names(groups_o4)[3] = "OK2"
names(groups_o4)[4] = "OK3"
names(groups_o4)[5] = "OK4"
names(groups_o4)[6] = "OK5"
finalt <- left_join(groups_p4,groups_o4)
#write_csv(finalt,"outputs/Estimation/bus_speed_ratios.csv")
```

## Validation
### Validation
After creating a full table representing the bus speed ratios by functional grouping, period, and area type we need to test how they actually worked. So, we updated the *05_Skim_Tran.s* voyager script to pull from our new calculated ratios and ran the TDM model again! This section runs some test to validate our ratios.

### Cumulative Travel Time Validation
One idea for validating the bus speeds is to run a similar analysis process we did in the Analysis tab, but steal the bus speed values from the links and compare those with the GTFS data. This process is explained in a similar outline of 4 steps.

  - *STEP 1*: Match the calculated transit speed, functional class, and area type of the nearest TDM link to each GTFS link. 
  
      a. Determine period (peak/off-peak) and compass direction (NB,SB,EB,WB) for all TDM links and GTFS links
      
      b. Join TDM speed attributes to GTFS links by period and compass direction
      
      c. Delete all GTFS links that were unable to match with a TDM link or matched with a link way too far away.
      
  - *STEP 2*: Using the GTFS link distance and the TDM speed, calculate the modeled link travel traverse time. Also calculate the GTFS observed link travel traverse time.
  
  - *STEP 3*: Calculate the cumulative link travel traverse time for both observed and modeled data by summing together travel times by period and functional classification and area type.
  
  - *STEP 4*: Calculate the modeled bus speed to observed bus speed ratio by dividing the cumulative travel traverse times. Do this by period and functional classification and area type. 

As you can see, the steps are basically the same, except we steal the newly calculated bus speeds off of the TDM instead of the congested speeds. We do not show the results on this document, because its basically the same process, but we do show the results below.

```{r, include = FALSE, warning=FALSE, message=FALSE}
tdmshpfile_nr <- "data/TDM/Distrib_Network_New_Ratios/Distrib_Network__Summary.shp"
transit_line_file_nr <- "data/TDM/Distrib_Network_New_Ratios/_v9_SE19_Net19_2_OD_Station_Detail.dbf"
```

```{r, include = FALSE, warning=FALSE, message=FALSE}
tdmlinkshp_nr <- st_read(tdmshpfile_nr, quiet = TRUE) %>%
  select(LINKID, FT, FTCLASS, AREATYPE, DIRECTION, AM_SPD, MD_SPD, 
         geometry, ATYPENAME, ATYPEGRP, PM_SPD, EV_SPD, EV_SPD, DY_SPD)
tdm_link_shp_attributes_nr <- tdmlinkshp_nr  %>% 
  as_tibble()
tdm_summary_all_nr <- read.dbf(transit_line_file_nr) %>%
  filter(MODE %in% c(4,5,6,9)) %>%
  group_by(MODE,NAME,NAMEID) %>%
  mutate(B = lead(A)) %>%
  select(MODE,NAMEID,NAME,ONEWAY,LINKSEQ1,LINKSEQ2,A,B,STOPS,DIST,
         P_SPEED1,O_SPEED1) %>%
  mutate(LINKID = paste0(A,"_",B)) %>%
  left_join(tdm_link_shp_attributes_nr) %>%
  filter(!is.na(FT)) %>%
  left_join(tdm_uta_conversion, by = c("NAME"="TDMRoute")) %>%
  select(-UTARoute,-Notes,-GTFSRoute) %>%
  mutate(compass = DIRECTION) %>%
  st_as_sf(crs = 26912) %>%
  st_transform(4326)
```

```{r, include = FALSE, warning=FALSE, message=FALSE}
gtfs_with_tdm_nr <- join_to_gtfs(tdm_summary_all_nr,gtfs_summary_centroids) %>%
  select(-Label.1, -LabelNum.1, -compass.1)

gtfs_with_tdm_short_nr <- gtfs_with_tdm_nr %>%
  select(LINKID, centroid_id,FT,FTCLASS,AREATYPE,AM_SPD,MD_SPD,P_SPEED1,O_SPEED1,dist, uniquerow) %>%
  as_tibble() %>% select(-midlinep)

gtfs_with_tdm_lines_nr <- gtfs_summary_all %>%
  left_join(gtfs_with_tdm_short_nr, by = c("uniquerow")) 
```

```{r, include = FALSE, warning=FALSE, message=FALSE}
labelnum <- 45
period <- "pk"

tdm_test_nr <- tdm_summary_all_nr %>%
  filter(LabelNum == 45) %>%
  st_as_sf()
gtfsp_test_nr <- gtfs_with_tdm_nr %>%
    ungroup()%>%
  mutate(long = unlist(map(gtfs_with_tdm_nr$midlinep,1)),
           lat = unlist(map(gtfs_with_tdm_nr$midlinep,2))) %>%
  filter(LabelNum == 45,
         PkOk == period)
gtfsl_test_nr <- gtfs_with_tdm_lines_nr %>%
  filter(LabelNum == 45,
         PkOk == period) %>%
  st_as_sf()
```

```{r, include = FALSE, warning=FALSE, message=FALSE}
leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolylines(
    data = tdm_test_nr$geometry,
    popup = paste("DIR: ", tdm_test_nr$compass, "<br>",
                  "AM Speed: ", tdm_test_nr$AM_SPD, "<br>",
                  "LINKID: ", tdm_test_nr$LINKID, "<br>",
                  "LINKSEQ1: ", tdm_test_nr$LINKSEQ1)
  ) %>%
  addCircleMarkers(lng = gtfsp_test_nr$long, 
      lat = gtfsp_test_nr$lat,
      popup = paste("DIR: ", gtfsp_test_nr$compass, "<br>",
                    "AM Speed: ", gtfsp_test_nr$AM_SPD, "<br>",
                    "LINKID: ", gtfsp_test_nr$LINKID, "<br>",
                    "LINKSEQ1: ", gtfsp_test_nr$LINKSEQ1),
      color = "red"
  ) %>%
  addPolylines(
    data = gtfsl_test_nr$geometry,
    popup = paste("DIR: ", gtfsl_test_nr$compass, "<br>",
                  "AM Speed: ", gtfsl_test_nr$AM_SPD, "<br>",
                  "LINKSEQ1: ", gtfsl_test_nr$LINKID, "<br>"),
    color = "red"
  )
```

```{r, include = FALSE, warning=FALSE, message=FALSE}
gtfs_with_tdm_clean_nr <- clean_gtfs_joint_data_validation(gtfs_with_tdm_lines_nr, 30, 2500)

traversetime_nr <- gtfs_with_tdm_clean_nr %>%
  mutate(ModeledTime = aveDistance / Modeled * 3600, 
         ObservedTime = aveDistance / Observed * 3600)

traversetime_ftg_nr <- traversetime_nr %>%
  as_tibble() %>% select(-geometry) %>%
  mutate(
      FTG = case_when(
        FT %in% c(1,4:10) ~ 1,       # collectors & locals
        FT == 3 ~  2,                # minor arterials
        FT == 2 ~ 3,                 # principal arterials
        FT %in% c(11:19) ~ 4,        # expressways
        FT %in% c(20:26,30:40) ~ 5,  # freeways
        FT %in% c(28:29,41:42) ~ 6,  # ramps
        TRUE ~ 0 
    )) %>%
    mutate(
      FTGCLASS= case_when(
        FTG == 1 ~ "1-Collectors & Locals",
        FTG == 2 ~ "2-Minor Arterials",
        FTG == 3 ~ "3-Principal Arterials",
        FTG == 4 ~ "4-Expressways",
        FTG == 5 ~ "5-Freeways",
        FTG == 6 ~ "6-Ramps",
        TRUE ~ "None"
    ))
```

```{r, include = FALSE, warning=FALSE, message=FALSE}
group3.2pDist <- traversetime_ftg_nr %>%
  group_by(PkOk, FTGCLASS, FTG, AREATYPE) %>%
    summarize(aveDistanceSum = sum(aveDistance))

group3.2dDist <- traversetime_ftg_nr %>%
  group_by(FTGCLASS, FTG, AREATYPE) %>%
    summarize(aveDistanceSum = sum(aveDistance)) %>%
    mutate(PkOk = "dt")
group3.2Dist <- bind_rows(group3.2pDist,group3.2dDist)
```

```{r, include = FALSE, message = FALSE, warning = FALSE}
group3.2p_areaT <- traversetime_ftg_nr %>%
  group_by(PkOk,AREATYPE) %>%
  summarize(ModeledTimeSum = sum(ModeledTime),
            ObservedTimeSum = sum(ObservedTime))
group3.2d_areaT <- traversetime_ftg_nr %>%
  group_by(AREATYPE) %>%
  summarize(ModeledTimeSum = sum(ModeledTime),
            ObservedTimeSum = sum(ObservedTime)) %>%
    mutate(PkOk = "dt")
group3.2_areaT <- bind_rows(group3.2d_areaT,group3.2p_areaT) %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum,
         pctError = (ObservedTimeSum - ModeledTimeSum) / ObservedTimeSum * 100) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  mutate(ratio = round(ratio,3),
         pctError = round(pctError,3))

area_dt_p <- group3.2_areaT %>%
  pivot_wider(c(PkOk),names_from = AREATYPE, values_from= ratio) %>%
  mutate(FTGCLASS = "6-All_FT")
area_dt_r <- group3.2_areaT %>%
    pivot_wider(c(PkOk),names_from = AREATYPE, values_from= pctError) %>%
  mutate(FTGCLASS = "6-All_FT")

megaval_p <- traversetime_ftg_nr %>%
  group_by(PkOk) %>%
  summarize(ModeledTimeSum = sum(ModeledTime),
            ObservedTimeSum = sum(ObservedTime))
megaval <- traversetime_ftg_nr %>%
  summarize(ModeledTimeSum = sum(ModeledTime),
            ObservedTimeSum = sum(ObservedTime)) %>%
  mutate(PkOk = "dt") %>%
  bind_rows(megaval_p) %>%
  mutate(All_R = ModeledTimeSum / ObservedTimeSum,
         All_P = abs(ObservedTimeSum - ModeledTimeSum) / ObservedTimeSum * 100) %>%
  mutate(FTGCLASS = "6-All_FT") %>%
  select(6,3,4,5)
megaval_r <- megaval %>% select(-All_P)
megaval_p <- megaval %>% select(-All_R)

group3.2p_ftgT <- traversetime_ftg_nr %>%
  group_by(PkOk,FTGCLASS) %>%
  summarize(ModeledTimeSum = sum(ModeledTime),
            ObservedTimeSum = sum(ObservedTime))
group3.2d_ftgT <- traversetime_ftg_nr %>%
  group_by(FTGCLASS) %>%
  summarize(ModeledTimeSum = sum(ModeledTime),
            ObservedTimeSum = sum(ObservedTime)) %>%
    mutate(PkOk = "dt")
group3.2_ftgT <- bind_rows(group3.2d_ftgT,group3.2p_ftgT) %>%
  mutate(ratio = ModeledTimeSum / ObservedTimeSum,
         pctError = (ObservedTimeSum - ModeledTimeSum) / ObservedTimeSum * 100) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  mutate(ratio = round(ratio,3),
         pctError = round(pctError,3)) %>%
  rename("All_R" = "ratio", "All_P" = "pctError")
```

```{r, include = FALSE, warning=FALSE, message=FALSE}
group3.2p <- traversetime_ftg_nr %>%
  group_by(PkOk, FTGCLASS, FTG, AREATYPE) %>%
    summarize(ModeledDistSum = sum(ModeledTime),
              ObservedDistSum = sum(ObservedTime))
group3.2d <- traversetime_ftg_nr %>%
  group_by(FTGCLASS, FTG, AREATYPE) %>%
    summarize(ModeledDistSum = sum(ModeledTime),
              ObservedDistSum = sum(ObservedTime)) %>%
    mutate(PkOk = "dt")
group3.2 <- bind_rows(group3.2d,group3.2p) %>%
  mutate(Group = 3, GroupName = "Grouped FT, All AT") %>%
  mutate(ratio = ModeledDistSum / ObservedDistSum,
         pctError = (ObservedDistSum - ModeledDistSum) / ObservedDistSum * 100) %>%
  ungroup() %>%
  filter(!is.na(ratio)) %>%
  mutate(ratio = round(ratio,3),
         pctError = round(pctError,3)) %>%
  select(PkOk,FTGCLASS, FTG, AREATYPE, pctError, ratio)

r_group3.2 <- group3.2 %>% select(-pctError) %>%
  pivot_wider(c(FTGCLASS,FTG,PkOk),names_from = AREATYPE, values_from= ratio) %>%
  select(2,1,3,8,4,5,6,7)
pe_group3.2 <- group3.2 %>% select(-ratio) %>%
  pivot_wider(c(FTGCLASS,FTG,PkOk),names_from = AREATYPE, values_from= pctError) %>%
  select(2,1,3,8,4,5,6,7)
```

```{r, include = FALSE}
ratioValidation <- r_group3.2 %>%
  filter(FTG != 6) %>%
  left_join(group3.2_ftgT, by = c("FTGCLASS","PkOk")) %>% select(-ModeledTimeSum, -ObservedTimeSum, -All_P) %>%
  bind_rows(area_dt_r) %>%
  left_join(megaval_r, by = c("FTGCLASS","PkOk")) %>%
  mutate(All_AT = ifelse(is.na(All_R.x), round(All_R.y,3), round(All_R.x,3))) %>%
  select(-All_R.y, -All_R.x)
pctErrorValidation <- pe_group3.2 %>%
  filter(FTG != 6) %>%
  left_join(group3.2_ftgT,  by = c("FTGCLASS","PkOk")) %>% select(-ModeledTimeSum, -ObservedTimeSum, -All_R) %>%
  bind_rows(area_dt_p) %>%
  left_join(megaval_p, by = c("FTGCLASS","PkOk")) %>%
    mutate(All_AT = ifelse(is.na(All_P.x), round(All_P.y,3), round(All_P.x,3))) %>%
  select(-All_P.y, -All_P.x)

rvd <- ratioValidation %>%
  filter(PkOk == "dt") %>% select(-PkOk, -FTG) %>% arrange(FTGCLASS)
rvp <- ratioValidation %>%
  filter(PkOk == "pk") %>% select(-PkOk, -FTG) %>% arrange(FTGCLASS)
rvo <- ratioValidation %>%
  filter(PkOk == "ok") %>% select(-PkOk, -FTG) %>% arrange(FTGCLASS)
pvd <- pctErrorValidation %>%
  filter(PkOk == "dt") %>% select(-PkOk, -FTG) %>% arrange(FTGCLASS)
pvp <- pctErrorValidation %>%
  filter(PkOk == "pk") %>% select(-PkOk, -FTG) %>% arrange(FTGCLASS)
pvo <- pctErrorValidation %>%
  filter(PkOk == "ok") %>% select(-PkOk, -FTG) %>% arrange(FTGCLASS)

```


#### Results
These are for the average results.
```{r, echo = FALSE}
kbl(rvd,
    caption = "Average Ratio Validation",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(pvd,
    caption = "Average Pct Error Validation",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

These are for the peak results.
```{r, echo = FALSE}
kbl(rvp,
    caption = "Peak Ratio Validation",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(pvp,
    caption = "Peak Pct Error Validation",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

These are for the off-peak results.
```{r, echo = FALSE}
kbl(rvo,
    caption = "Off-Peak Ratio Validation",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
kbl(pvo,
    caption = "Off-Peak Pct Error Validation",) %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

### Link Speed Validation

